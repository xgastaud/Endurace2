{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n *         ,/\n *       ,'/\n *     ,' /\n *   ,'  /_____,\n * .'____    ,'\n *      /  ,'\n *     / ,'\n *    /,'\n *   /'\n *\n * Selectric ÏŸ v1.13.0 (Aug 22 2017) - http://lcdsantos.github.io/jQuery-Selectric/\n *\n * Copyright (c) 2017 Leonardo Santos; MIT License\n *\n */\n(function (factory) {\n  /* global define */\n\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = function (root, jQuery) {\n      if (jQuery === undefined) {\n        if (typeof window !== 'undefined') {\n          jQuery = require('jquery');\n        } else {\n          jQuery = require('jquery')(root);\n        }\n      }\n\n      factory(jQuery);\n      return jQuery;\n    };\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n})(function ($) {\n  'use strict';\n\n  var $doc = $(document);\n  var $win = $(window);\n  var pluginName = 'selectric';\n  var classList = 'Input Items Open Disabled TempShow HideSelect Wrapper Focus Hover Responsive Above Below Scroll Group GroupLabel';\n  var eventNamespaceSuffix = '.sl';\n  var chars = ['a', 'e', 'i', 'o', 'u', 'n', 'c', 'y'];\n  var diacritics = [/[\\xE0-\\xE5]/g, // a\n  /[\\xE8-\\xEB]/g, // e\n  /[\\xEC-\\xEF]/g, // i\n  /[\\xF2-\\xF6]/g, // o\n  /[\\xF9-\\xFC]/g, // u\n  /[\\xF1]/g, // n\n  /[\\xE7]/g, // c\n  /[\\xFD-\\xFF]/g // y\n  ];\n  /**\n   * Create an instance of Selectric\n   *\n   * @constructor\n   * @param {Node} element - The &lt;select&gt; element\n   * @param {object}  opts - Options\n   */\n\n  var Selectric = function Selectric(element, opts) {\n    var _this = this;\n\n    _this.element = element;\n    _this.$element = $(element);\n    _this.state = {\n      multiple: !!_this.$element.attr('multiple'),\n      enabled: false,\n      opened: false,\n      currValue: -1,\n      selectedIdx: -1,\n      highlightedIdx: -1\n    };\n    _this.eventTriggers = {\n      open: _this.open,\n      close: _this.close,\n      destroy: _this.destroy,\n      refresh: _this.refresh,\n      init: _this.init\n    };\n\n    _this.init(opts);\n  };\n\n  Selectric.prototype = {\n    utils: {\n      /**\n       * Detect mobile browser\n       *\n       * @return {boolean}\n       */\n      isMobile: function isMobile() {\n        return /android|ip(hone|od|ad)/i.test(navigator.userAgent);\n      },\n\n      /**\n       * Escape especial characters in string (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n       *\n       * @param  {string} str - The string to be escaped\n       * @return {string}       The string with the special characters escaped\n       */\n      escapeRegExp: function escapeRegExp(str) {\n        return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n      },\n\n      /**\n       * Replace diacritics\n       *\n       * @param  {string} str - The string to replace the diacritics\n       * @return {string}       The string with diacritics replaced with ascii characters\n       */\n      replaceDiacritics: function replaceDiacritics(str) {\n        var k = diacritics.length;\n\n        while (k--) {\n          str = str.toLowerCase().replace(diacritics[k], chars[k]);\n        }\n\n        return str;\n      },\n\n      /**\n       * Format string\n       * https://gist.github.com/atesgoral/984375\n       *\n       * @param  {string} f - String to be formated\n       * @return {string}     String formated\n       */\n      format: function format(f) {\n        var a = arguments; // store outer arguments\n\n        return ('' + f). // force format specifier to String\n        replace( // replace tokens in format specifier\n        /\\{(?:(\\d+)|(\\w+))\\}/g, // match {token} references\n        function (s, // the matched string (ignored)\n        i, // an argument index\n        p // a property name\n        ) {\n          return p && a[1] // if property name and first argument exist\n          ? a[1][p] // return property from first argument\n          : a[i]; // assume argument index and return i-th argument\n        });\n      },\n\n      /**\n       * Get the next enabled item in the options list.\n       *\n       * @param  {object} selectItems - The options object.\n       * @param  {number}    selected - Index of the currently selected option.\n       * @return {object}               The next enabled item.\n       */\n      nextEnabledItem: function nextEnabledItem(selectItems, selected) {\n        while (selectItems[selected = (selected + 1) % selectItems.length].disabled) {// empty\n        }\n\n        return selected;\n      },\n\n      /**\n       * Get the previous enabled item in the options list.\n       *\n       * @param  {object} selectItems - The options object.\n       * @param  {number}    selected - Index of the currently selected option.\n       * @return {object}               The previous enabled item.\n       */\n      previousEnabledItem: function previousEnabledItem(selectItems, selected) {\n        while (selectItems[selected = (selected > 0 ? selected : selectItems.length) - 1].disabled) {// empty\n        }\n\n        return selected;\n      },\n\n      /**\n       * Transform camelCase string to dash-case.\n       *\n       * @param  {string} str - The camelCased string.\n       * @return {string}       The string transformed to dash-case.\n       */\n      toDash: function toDash(str) {\n        return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n      },\n\n      /**\n       * Calls the events registered with function name.\n       *\n       * @param {string}    fn - The name of the function.\n       * @param {number} scope - Scope that should be set on the function.\n       */\n      triggerCallback: function triggerCallback(fn, scope) {\n        var elm = scope.element;\n        var func = scope.options['on' + fn];\n        var args = [elm].concat([].slice.call(arguments).slice(1));\n\n        if ($.isFunction(func)) {\n          func.apply(elm, args);\n        }\n\n        $(elm).trigger(pluginName + '-' + this.toDash(fn), args);\n      },\n\n      /**\n       * Transform array list to concatenated string and remove empty values\n       * @param  {array} arr - Class list\n       * @return {string}      Concatenated string\n       */\n      arrayToClassname: function arrayToClassname(arr) {\n        var newArr = $.grep(arr, function (item) {\n          return !!item;\n        });\n        return $.trim(newArr.join(' '));\n      }\n    },\n\n    /** Initializes */\n    init: function init(opts) {\n      var _this = this; // Set options\n\n\n      _this.options = $.extend(true, {}, $.fn[pluginName].defaults, _this.options, opts);\n\n      _this.utils.triggerCallback('BeforeInit', _this); // Preserve data\n\n\n      _this.destroy(true); // Disable on mobile browsers\n\n\n      if (_this.options.disableOnMobile && _this.utils.isMobile()) {\n        _this.disableOnMobile = true;\n        return;\n      } // Get classes\n\n\n      _this.classes = _this.getClassNames(); // Create elements\n\n      var input = $('<input/>', {\n        'class': _this.classes.input,\n        'readonly': _this.utils.isMobile()\n      });\n      var items = $('<div/>', {\n        'class': _this.classes.items,\n        'tabindex': -1\n      });\n      var itemsScroll = $('<div/>', {\n        'class': _this.classes.scroll\n      });\n      var wrapper = $('<div/>', {\n        'class': _this.classes.prefix,\n        'html': _this.options.arrowButtonMarkup\n      });\n      var label = $('<span/>', {\n        'class': 'label'\n      });\n\n      var outerWrapper = _this.$element.wrap('<div/>').parent().append(wrapper.prepend(label), items, input);\n\n      var hideSelectWrapper = $('<div/>', {\n        'class': _this.classes.hideselect\n      });\n      _this.elements = {\n        input: input,\n        items: items,\n        itemsScroll: itemsScroll,\n        wrapper: wrapper,\n        label: label,\n        outerWrapper: outerWrapper\n      };\n\n      if (_this.options.nativeOnMobile && _this.utils.isMobile()) {\n        _this.elements.input = undefined;\n        hideSelectWrapper.addClass(_this.classes.prefix + '-is-native');\n\n        _this.$element.on('change', function () {\n          _this.refresh();\n        });\n      }\n\n      _this.$element.on(_this.eventTriggers).wrap(hideSelectWrapper);\n\n      _this.originalTabindex = _this.$element.prop('tabindex');\n\n      _this.$element.prop('tabindex', -1);\n\n      _this.populate();\n\n      _this.activate();\n\n      _this.utils.triggerCallback('Init', _this);\n    },\n\n    /** Activates the plugin */\n    activate: function activate() {\n      var _this = this;\n\n      var hiddenChildren = _this.elements.items.closest(':visible').children(':hidden').addClass(_this.classes.tempshow);\n\n      var originalWidth = _this.$element.width();\n\n      hiddenChildren.removeClass(_this.classes.tempshow);\n\n      _this.utils.triggerCallback('BeforeActivate', _this);\n\n      _this.elements.outerWrapper.prop('class', _this.utils.arrayToClassname([_this.classes.wrapper, _this.$element.prop('class').replace(/\\S+/g, _this.classes.prefix + '-$&'), _this.options.responsive ? _this.classes.responsive : '']));\n\n      if (_this.options.inheritOriginalWidth && originalWidth > 0) {\n        _this.elements.outerWrapper.width(originalWidth);\n      }\n\n      _this.unbindEvents();\n\n      if (!_this.$element.prop('disabled')) {\n        _this.state.enabled = true; // Not disabled, so... Removing disabled class\n\n        _this.elements.outerWrapper.removeClass(_this.classes.disabled); // Remove styles from items box\n        // Fix incorrect height when refreshed is triggered with fewer options\n\n\n        _this.$li = _this.elements.items.removeAttr('style').find('li');\n\n        _this.bindEvents();\n      } else {\n        _this.elements.outerWrapper.addClass(_this.classes.disabled);\n\n        if (_this.elements.input) {\n          _this.elements.input.prop('disabled', true);\n        }\n      }\n\n      _this.utils.triggerCallback('Activate', _this);\n    },\n\n    /**\n     * Generate classNames for elements\n     *\n     * @return {object} Classes object\n     */\n    getClassNames: function getClassNames() {\n      var _this = this;\n\n      var customClass = _this.options.customClass;\n      var classesObj = {};\n      $.each(classList.split(' '), function (i, currClass) {\n        var c = customClass.prefix + currClass;\n        classesObj[currClass.toLowerCase()] = customClass.camelCase ? c : _this.utils.toDash(c);\n      });\n      classesObj.prefix = customClass.prefix;\n      return classesObj;\n    },\n\n    /** Set the label text */\n    setLabel: function setLabel() {\n      var _this = this;\n\n      var labelBuilder = _this.options.labelBuilder;\n\n      if (_this.state.multiple) {\n        // Make sure currentValues is an array\n        var currentValues = $.isArray(_this.state.currValue) ? _this.state.currValue : [_this.state.currValue]; // I'm not happy with this, but currentValues can be an empty\n        // array and we need to fallback to the default option.\n\n        currentValues = currentValues.length === 0 ? [0] : currentValues;\n        var labelMarkup = $.map(currentValues, function (value) {\n          return $.grep(_this.lookupItems, function (item) {\n            return item.index === value;\n          })[0]; // we don't want nested arrays here\n        });\n        labelMarkup = $.grep(labelMarkup, function (item) {\n          // Hide default (please choose) if more then one element were selected.\n          // If no option value were given value is set to option text by default\n          if (labelMarkup.length > 1 || labelMarkup.length === 0) {\n            return $.trim(item.value) !== '';\n          }\n\n          return item;\n        });\n        labelMarkup = $.map(labelMarkup, function (item) {\n          return $.isFunction(labelBuilder) ? labelBuilder(item) : _this.utils.format(labelBuilder, item);\n        }); // Limit the amount of selected values shown in label\n\n        if (_this.options.multiple.maxLabelEntries) {\n          if (labelMarkup.length >= _this.options.multiple.maxLabelEntries + 1) {\n            labelMarkup = labelMarkup.slice(0, _this.options.multiple.maxLabelEntries);\n            labelMarkup.push($.isFunction(labelBuilder) ? labelBuilder({\n              text: '...'\n            }) : _this.utils.format(labelBuilder, {\n              text: '...'\n            }));\n          } else {\n            labelMarkup.slice(labelMarkup.length - 1);\n          }\n        }\n\n        _this.elements.label.html(labelMarkup.join(_this.options.multiple.separator));\n      } else {\n        var currItem = _this.lookupItems[_this.state.currValue];\n\n        _this.elements.label.html($.isFunction(labelBuilder) ? labelBuilder(currItem) : _this.utils.format(labelBuilder, currItem));\n      }\n    },\n\n    /** Get and save the available options */\n    populate: function populate() {\n      var _this = this;\n\n      var $options = _this.$element.children();\n\n      var $justOptions = _this.$element.find('option');\n\n      var $selected = $justOptions.filter(':selected');\n      var selectedIndex = $justOptions.index($selected);\n      var currIndex = 0;\n      var emptyValue = _this.state.multiple ? [] : 0;\n\n      if ($selected.length > 1 && _this.state.multiple) {\n        selectedIndex = [];\n        $selected.each(function () {\n          selectedIndex.push($(this).index());\n        });\n      }\n\n      _this.state.currValue = ~selectedIndex ? selectedIndex : emptyValue;\n      _this.state.selectedIdx = _this.state.currValue;\n      _this.state.highlightedIdx = _this.state.currValue;\n      _this.items = [];\n      _this.lookupItems = [];\n\n      if ($options.length) {\n        // Build options markup\n        $options.each(function (i) {\n          var $elm = $(this);\n\n          if ($elm.is('optgroup')) {\n            var optionsGroup = {\n              element: $elm,\n              label: $elm.prop('label'),\n              groupDisabled: $elm.prop('disabled'),\n              items: []\n            };\n            $elm.children().each(function (i) {\n              var $elm = $(this);\n              optionsGroup.items[i] = _this.getItemData(currIndex, $elm, optionsGroup.groupDisabled || $elm.prop('disabled'));\n              _this.lookupItems[currIndex] = optionsGroup.items[i];\n              currIndex++;\n            });\n            _this.items[i] = optionsGroup;\n          } else {\n            _this.items[i] = _this.getItemData(currIndex, $elm, $elm.prop('disabled'));\n            _this.lookupItems[currIndex] = _this.items[i];\n            currIndex++;\n          }\n        });\n\n        _this.setLabel();\n\n        _this.elements.items.append(_this.elements.itemsScroll.html(_this.getItemsMarkup(_this.items)));\n      }\n    },\n\n    /**\n     * Generate items object data\n     * @param  {integer} index      - Current item index\n     * @param  {node}    $elm       - Current element node\n     * @param  {boolean} isDisabled - Current element disabled state\n     * @return {object}               Item object\n     */\n    getItemData: function getItemData(index, $elm, isDisabled) {\n      var _this = this;\n\n      return {\n        index: index,\n        element: $elm,\n        value: $elm.val(),\n        className: $elm.prop('class'),\n        text: $elm.html(),\n        slug: $.trim(_this.utils.replaceDiacritics($elm.html())),\n        alt: $elm.attr('data-alt'),\n        selected: $elm.prop('selected'),\n        disabled: isDisabled\n      };\n    },\n\n    /**\n     * Generate options markup\n     *\n     * @param  {object} items - Object containing all available options\n     * @return {string}         HTML for the options box\n     */\n    getItemsMarkup: function getItemsMarkup(items) {\n      var _this = this;\n\n      var markup = '<ul>';\n\n      if ($.isFunction(_this.options.listBuilder) && _this.options.listBuilder) {\n        items = _this.options.listBuilder(items);\n      }\n\n      $.each(items, function (i, elm) {\n        if (elm.label !== undefined) {\n          markup += _this.utils.format('<ul class=\"{1}\"><li class=\"{2}\">{3}</li>', _this.utils.arrayToClassname([_this.classes.group, elm.groupDisabled ? 'disabled' : '', elm.element.prop('class')]), _this.classes.grouplabel, elm.element.prop('label'));\n          $.each(elm.items, function (i, elm) {\n            markup += _this.getItemMarkup(elm.index, elm);\n          });\n          markup += '</ul>';\n        } else {\n          markup += _this.getItemMarkup(elm.index, elm);\n        }\n      });\n      return markup + '</ul>';\n    },\n\n    /**\n     * Generate every option markup\n     *\n     * @param  {number} index    - Index of current item\n     * @param  {object} itemData - Current item\n     * @return {string}            HTML for the option\n     */\n    getItemMarkup: function getItemMarkup(index, itemData) {\n      var _this = this;\n\n      var itemBuilder = _this.options.optionsItemBuilder; // limit access to item data to provide a simple interface\n      // to most relevant options.\n\n      var filteredItemData = {\n        value: itemData.value,\n        text: itemData.text,\n        slug: itemData.slug,\n        index: itemData.index\n      };\n      return _this.utils.format('<li data-index=\"{1}\" class=\"{2}\">{3}</li>', index, _this.utils.arrayToClassname([itemData.className, index === _this.items.length - 1 ? 'last' : '', itemData.disabled ? 'disabled' : '', itemData.selected ? 'selected' : '']), $.isFunction(itemBuilder) ? _this.utils.format(itemBuilder(itemData, this.$element, index), itemData) : _this.utils.format(itemBuilder, filteredItemData));\n    },\n\n    /** Remove events on the elements */\n    unbindEvents: function unbindEvents() {\n      var _this = this;\n\n      _this.elements.wrapper.add(_this.$element).add(_this.elements.outerWrapper).add(_this.elements.input).off(eventNamespaceSuffix);\n    },\n\n    /** Bind events on the elements */\n    bindEvents: function bindEvents() {\n      var _this = this;\n\n      _this.elements.outerWrapper.on('mouseenter' + eventNamespaceSuffix + ' mouseleave' + eventNamespaceSuffix, function (e) {\n        $(this).toggleClass(_this.classes.hover, e.type === 'mouseenter'); // Delay close effect when openOnHover is true\n\n        if (_this.options.openOnHover) {\n          clearTimeout(_this.closeTimer);\n\n          if (e.type === 'mouseleave') {\n            _this.closeTimer = setTimeout($.proxy(_this.close, _this), _this.options.hoverIntentTimeout);\n          } else {\n            _this.open();\n          }\n        }\n      }); // Toggle open/close\n\n\n      _this.elements.wrapper.on('click' + eventNamespaceSuffix, function (e) {\n        _this.state.opened ? _this.close() : _this.open(e);\n      }); // Translate original element focus event to dummy input.\n      // Disabled on mobile devices because the default option list isn't\n      // shown due the fact that hidden input gets focused\n\n\n      if (!(_this.options.nativeOnMobile && _this.utils.isMobile())) {\n        _this.$element.on('focus' + eventNamespaceSuffix, function () {\n          _this.elements.input.focus();\n        });\n\n        _this.elements.input.prop({\n          tabindex: _this.originalTabindex,\n          disabled: false\n        }).on('keydown' + eventNamespaceSuffix, $.proxy(_this.handleKeys, _this)).on('focusin' + eventNamespaceSuffix, function (e) {\n          _this.elements.outerWrapper.addClass(_this.classes.focus); // Prevent the flicker when focusing out and back again in the browser window\n\n\n          _this.elements.input.one('blur', function () {\n            _this.elements.input.blur();\n          });\n\n          if (_this.options.openOnFocus && !_this.state.opened) {\n            _this.open(e);\n          }\n        }).on('focusout' + eventNamespaceSuffix, function () {\n          _this.elements.outerWrapper.removeClass(_this.classes.focus);\n        }).on('input propertychange', function () {\n          var val = _this.elements.input.val();\n\n          var searchRegExp = new RegExp('^' + _this.utils.escapeRegExp(val), 'i'); // Clear search\n\n          clearTimeout(_this.resetStr);\n          _this.resetStr = setTimeout(function () {\n            _this.elements.input.val('');\n          }, _this.options.keySearchTimeout);\n\n          if (val.length) {\n            // Search in select options\n            $.each(_this.items, function (i, elm) {\n              if (elm.disabled) {\n                return;\n              }\n\n              if (searchRegExp.test(elm.text) || searchRegExp.test(elm.slug)) {\n                _this.highlight(i);\n\n                return;\n              }\n\n              if (!elm.alt) {\n                return;\n              }\n\n              var altItems = elm.alt.split('|');\n\n              for (var ai = 0; ai < altItems.length; ai++) {\n                if (!altItems[ai]) {\n                  break;\n                }\n\n                if (searchRegExp.test(altItems[ai].trim())) {\n                  _this.highlight(i);\n\n                  return;\n                }\n              }\n            });\n          }\n        });\n      }\n\n      _this.$li.on({\n        // Prevent <input> blur on Chrome\n        mousedown: function mousedown(e) {\n          e.preventDefault();\n          e.stopPropagation();\n        },\n        click: function click() {\n          _this.select($(this).data('index')); // Chrome doesn't close options box if select is wrapped with a label\n          // We need to 'return false' to avoid that\n\n\n          return false;\n        }\n      });\n    },\n\n    /**\n     * Behavior when keyboard keys is pressed\n     *\n     * @param {object} e - Event object\n     */\n    handleKeys: function handleKeys(e) {\n      var _this = this;\n\n      var key = e.which;\n      var keys = _this.options.keys;\n      var isPrevKey = $.inArray(key, keys.previous) > -1;\n      var isNextKey = $.inArray(key, keys.next) > -1;\n      var isSelectKey = $.inArray(key, keys.select) > -1;\n      var isOpenKey = $.inArray(key, keys.open) > -1;\n      var idx = _this.state.highlightedIdx;\n      var isFirstOrLastItem = isPrevKey && idx === 0 || isNextKey && idx + 1 === _this.items.length;\n      var goToItem = 0; // Enter / Space\n\n      if (key === 13 || key === 32) {\n        e.preventDefault();\n      } // If it's a directional key\n\n\n      if (isPrevKey || isNextKey) {\n        if (!_this.options.allowWrap && isFirstOrLastItem) {\n          return;\n        }\n\n        if (isPrevKey) {\n          goToItem = _this.utils.previousEnabledItem(_this.lookupItems, idx);\n        }\n\n        if (isNextKey) {\n          goToItem = _this.utils.nextEnabledItem(_this.lookupItems, idx);\n        }\n\n        _this.highlight(goToItem);\n      } // Tab / Enter / ESC\n\n\n      if (isSelectKey && _this.state.opened) {\n        _this.select(idx);\n\n        if (!_this.state.multiple || !_this.options.multiple.keepMenuOpen) {\n          _this.close();\n        }\n\n        return;\n      } // Space / Enter / Left / Up / Right / Down\n\n\n      if (isOpenKey && !_this.state.opened) {\n        _this.open();\n      }\n    },\n\n    /** Update the items object */\n    refresh: function refresh() {\n      var _this = this;\n\n      _this.populate();\n\n      _this.activate();\n\n      _this.utils.triggerCallback('Refresh', _this);\n    },\n\n    /** Set options box width/height */\n    setOptionsDimensions: function setOptionsDimensions() {\n      var _this = this; // Calculate options box height\n      // Set a temporary class on the hidden parent of the element\n\n\n      var hiddenChildren = _this.elements.items.closest(':visible').children(':hidden').addClass(_this.classes.tempshow);\n\n      var maxHeight = _this.options.maxHeight;\n\n      var itemsWidth = _this.elements.items.outerWidth();\n\n      var wrapperWidth = _this.elements.wrapper.outerWidth() - (itemsWidth - _this.elements.items.width()); // Set the dimensions, minimum is wrapper width, expand for long items if option is true\n\n\n      if (!_this.options.expandToItemText || wrapperWidth > itemsWidth) {\n        _this.finalWidth = wrapperWidth;\n      } else {\n        // Make sure the scrollbar width is included\n        _this.elements.items.css('overflow', 'scroll'); // Set a really long width for _this.elements.outerWrapper\n\n\n        _this.elements.outerWrapper.width(9e4);\n\n        _this.finalWidth = _this.elements.items.width(); // Set scroll bar to auto\n\n        _this.elements.items.css('overflow', '');\n\n        _this.elements.outerWrapper.width('');\n      }\n\n      _this.elements.items.width(_this.finalWidth).height() > maxHeight && _this.elements.items.height(maxHeight); // Remove the temporary class\n\n      hiddenChildren.removeClass(_this.classes.tempshow);\n    },\n\n    /** Detect if the options box is inside the window */\n    isInViewport: function isInViewport() {\n      var _this = this;\n\n      if (_this.options.forceRenderAbove === true) {\n        _this.elements.outerWrapper.addClass(_this.classes.above);\n      } else if (_this.options.forceRenderBelow === true) {\n        _this.elements.outerWrapper.addClass(_this.classes.below);\n      } else {\n        var scrollTop = $win.scrollTop();\n        var winHeight = $win.height();\n\n        var uiPosX = _this.elements.outerWrapper.offset().top;\n\n        var uiHeight = _this.elements.outerWrapper.outerHeight();\n\n        var fitsDown = uiPosX + uiHeight + _this.itemsHeight <= scrollTop + winHeight;\n        var fitsAbove = uiPosX - _this.itemsHeight > scrollTop; // If it does not fit below, only render it\n        // above it fit's there.\n        // It's acceptable that the user needs to\n        // scroll the viewport to see the cut off UI\n\n        var renderAbove = !fitsDown && fitsAbove;\n        var renderBelow = !renderAbove;\n\n        _this.elements.outerWrapper.toggleClass(_this.classes.above, renderAbove);\n\n        _this.elements.outerWrapper.toggleClass(_this.classes.below, renderBelow);\n      }\n    },\n\n    /**\n     * Detect if currently selected option is visible and scroll the options box to show it\n     *\n     * @param {Number|Array} index - Index of the selected items\n     */\n    detectItemVisibility: function detectItemVisibility(index) {\n      var _this = this;\n\n      var $filteredLi = _this.$li.filter('[data-index]');\n\n      if (_this.state.multiple) {\n        // If index is an array, we can assume a multiple select and we\n        // want to scroll to the uppermost selected item!\n        // Math.min.apply(Math, index) returns the lowest entry in an Array.\n        index = $.isArray(index) && index.length === 0 ? 0 : index;\n        index = $.isArray(index) ? Math.min.apply(Math, index) : index;\n      }\n\n      var liHeight = $filteredLi.eq(index).outerHeight();\n      var liTop = $filteredLi[index].offsetTop;\n\n      var itemsScrollTop = _this.elements.itemsScroll.scrollTop();\n\n      var scrollT = liTop + liHeight * 2;\n\n      _this.elements.itemsScroll.scrollTop(scrollT > itemsScrollTop + _this.itemsHeight ? scrollT - _this.itemsHeight : liTop - liHeight < itemsScrollTop ? liTop - liHeight : itemsScrollTop);\n    },\n\n    /**\n     * Open the select options box\n     *\n     * @param {Event} e - Event\n     */\n    open: function open(e) {\n      var _this = this;\n\n      if (_this.options.nativeOnMobile && _this.utils.isMobile()) {\n        return false;\n      }\n\n      _this.utils.triggerCallback('BeforeOpen', _this);\n\n      if (e) {\n        e.preventDefault();\n\n        if (_this.options.stopPropagation) {\n          e.stopPropagation();\n        }\n      }\n\n      if (_this.state.enabled) {\n        _this.setOptionsDimensions(); // Find any other opened instances of select and close it\n\n\n        $('.' + _this.classes.hideselect, '.' + _this.classes.open).children()[pluginName]('close');\n        _this.state.opened = true;\n        _this.itemsHeight = _this.elements.items.outerHeight();\n        _this.itemsInnerHeight = _this.elements.items.height(); // Toggle options box visibility\n\n        _this.elements.outerWrapper.addClass(_this.classes.open); // Give dummy input focus\n\n\n        _this.elements.input.val('');\n\n        if (e && e.type !== 'focusin') {\n          _this.elements.input.focus();\n        } // Delayed binds events on Document to make label clicks work\n\n\n        setTimeout(function () {\n          $doc.on('click' + eventNamespaceSuffix, $.proxy(_this.close, _this)).on('scroll' + eventNamespaceSuffix, $.proxy(_this.isInViewport, _this));\n        }, 1);\n\n        _this.isInViewport(); // Prevent window scroll when using mouse wheel inside items box\n\n\n        if (_this.options.preventWindowScroll) {\n          /* istanbul ignore next */\n          $doc.on('mousewheel' + eventNamespaceSuffix + ' DOMMouseScroll' + eventNamespaceSuffix, '.' + _this.classes.scroll, function (e) {\n            var orgEvent = e.originalEvent;\n            var scrollTop = $(this).scrollTop();\n            var deltaY = 0;\n\n            if ('detail' in orgEvent) {\n              deltaY = orgEvent.detail * -1;\n            }\n\n            if ('wheelDelta' in orgEvent) {\n              deltaY = orgEvent.wheelDelta;\n            }\n\n            if ('wheelDeltaY' in orgEvent) {\n              deltaY = orgEvent.wheelDeltaY;\n            }\n\n            if ('deltaY' in orgEvent) {\n              deltaY = orgEvent.deltaY * -1;\n            }\n\n            if (scrollTop === this.scrollHeight - _this.itemsInnerHeight && deltaY < 0 || scrollTop === 0 && deltaY > 0) {\n              e.preventDefault();\n            }\n          });\n        }\n\n        _this.detectItemVisibility(_this.state.selectedIdx);\n\n        _this.highlight(_this.state.multiple ? -1 : _this.state.selectedIdx);\n\n        _this.utils.triggerCallback('Open', _this);\n      }\n    },\n\n    /** Close the select options box */\n    close: function close() {\n      var _this = this;\n\n      _this.utils.triggerCallback('BeforeClose', _this); // Remove custom events on document\n\n\n      $doc.off(eventNamespaceSuffix); // Remove visible class to hide options box\n\n      _this.elements.outerWrapper.removeClass(_this.classes.open);\n\n      _this.state.opened = false;\n\n      _this.utils.triggerCallback('Close', _this);\n    },\n\n    /** Select current option and change the label */\n    change: function change() {\n      var _this = this;\n\n      _this.utils.triggerCallback('BeforeChange', _this);\n\n      if (_this.state.multiple) {\n        // Reset old selected\n        $.each(_this.lookupItems, function (idx) {\n          _this.lookupItems[idx].selected = false;\n\n          _this.$element.find('option').prop('selected', false);\n        }); // Set new selected\n\n        $.each(_this.state.selectedIdx, function (idx, value) {\n          _this.lookupItems[value].selected = true;\n\n          _this.$element.find('option').eq(value).prop('selected', true);\n        });\n        _this.state.currValue = _this.state.selectedIdx;\n\n        _this.setLabel();\n\n        _this.utils.triggerCallback('Change', _this);\n      } else if (_this.state.currValue !== _this.state.selectedIdx) {\n        // Apply changed value to original select\n        _this.$element.prop('selectedIndex', _this.state.currValue = _this.state.selectedIdx).data('value', _this.lookupItems[_this.state.selectedIdx].text); // Change label text\n\n\n        _this.setLabel();\n\n        _this.utils.triggerCallback('Change', _this);\n      }\n    },\n\n    /**\n     * Highlight option\n     * @param {number} index - Index of the options that will be highlighted\n     */\n    highlight: function highlight(index) {\n      var _this = this;\n\n      var $filteredLi = _this.$li.filter('[data-index]').removeClass('highlighted');\n\n      _this.utils.triggerCallback('BeforeHighlight', _this); // Parameter index is required and should not be a disabled item\n\n\n      if (index === undefined || index === -1 || _this.lookupItems[index].disabled) {\n        return;\n      }\n\n      $filteredLi.eq(_this.state.highlightedIdx = index).addClass('highlighted');\n\n      _this.detectItemVisibility(index);\n\n      _this.utils.triggerCallback('Highlight', _this);\n    },\n\n    /**\n     * Select option\n     *\n     * @param {number} index - Index of the option that will be selected\n     */\n    select: function select(index) {\n      var _this = this;\n\n      var $filteredLi = _this.$li.filter('[data-index]');\n\n      _this.utils.triggerCallback('BeforeSelect', _this, index); // Parameter index is required and should not be a disabled item\n\n\n      if (index === undefined || index === -1 || _this.lookupItems[index].disabled) {\n        return;\n      }\n\n      if (_this.state.multiple) {\n        // Make sure selectedIdx is an array\n        _this.state.selectedIdx = $.isArray(_this.state.selectedIdx) ? _this.state.selectedIdx : [_this.state.selectedIdx];\n        var hasSelectedIndex = $.inArray(index, _this.state.selectedIdx);\n\n        if (hasSelectedIndex !== -1) {\n          _this.state.selectedIdx.splice(hasSelectedIndex, 1);\n        } else {\n          _this.state.selectedIdx.push(index);\n        }\n\n        $filteredLi.removeClass('selected').filter(function (index) {\n          return $.inArray(index, _this.state.selectedIdx) !== -1;\n        }).addClass('selected');\n      } else {\n        $filteredLi.removeClass('selected').eq(_this.state.selectedIdx = index).addClass('selected');\n      }\n\n      if (!_this.state.multiple || !_this.options.multiple.keepMenuOpen) {\n        _this.close();\n      }\n\n      _this.change();\n\n      _this.utils.triggerCallback('Select', _this, index);\n    },\n\n    /**\n     * Unbind and remove\n     *\n     * @param {boolean} preserveData - Check if the data on the element should be removed too\n     */\n    destroy: function destroy(preserveData) {\n      var _this = this;\n\n      if (_this.state && _this.state.enabled) {\n        _this.elements.items.add(_this.elements.wrapper).add(_this.elements.input).remove();\n\n        if (!preserveData) {\n          _this.$element.removeData(pluginName).removeData('value');\n        }\n\n        _this.$element.prop('tabindex', _this.originalTabindex).off(eventNamespaceSuffix).off(_this.eventTriggers).unwrap().unwrap();\n\n        _this.state.enabled = false;\n      }\n    }\n  }; // A really lightweight plugin wrapper around the constructor,\n  // preventing against multiple instantiations\n\n  $.fn[pluginName] = function (args) {\n    return this.each(function () {\n      var data = $.data(this, pluginName);\n\n      if (data && !data.disableOnMobile) {\n        typeof args === 'string' && data[args] ? data[args]() : data.init(args);\n      } else {\n        $.data(this, pluginName, new Selectric(this, args));\n      }\n    });\n  };\n  /**\n   * Default plugin options\n   *\n   * @type {object}\n   */\n\n\n  $.fn[pluginName].defaults = {\n    onChange: function onChange(elm) {\n      $(elm).change();\n    },\n    maxHeight: 300,\n    keySearchTimeout: 500,\n    arrowButtonMarkup: '<b class=\"button\">&#x25be;</b>',\n    disableOnMobile: false,\n    nativeOnMobile: true,\n    openOnFocus: true,\n    openOnHover: false,\n    hoverIntentTimeout: 500,\n    expandToItemText: false,\n    responsive: false,\n    preventWindowScroll: true,\n    inheritOriginalWidth: false,\n    allowWrap: true,\n    forceRenderAbove: false,\n    forceRenderBelow: false,\n    stopPropagation: true,\n    optionsItemBuilder: '{text}',\n    // function(itemData, element, index)\n    labelBuilder: '{text}',\n    // function(currItem)\n    listBuilder: false,\n    // function(items)\n    keys: {\n      previous: [37, 38],\n      // Left / Up\n      next: [39, 40],\n      // Right / Down\n      select: [9, 13, 27],\n      // Tab / Enter / Escape\n      open: [13, 32, 37, 38, 39, 40],\n      // Enter / Space / Left / Up / Right / Down\n      close: [9, 27] // Tab / Escape\n\n    },\n    customClass: {\n      prefix: pluginName,\n      camelCase: false\n    },\n    multiple: {\n      separator: ', ',\n      keepMenuOpen: true,\n      maxLabelEntries: false\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"module"}